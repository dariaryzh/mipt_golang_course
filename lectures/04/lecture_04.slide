# Программирование на языке Go

Лекция 4. Defer и Panic. Интерфейсы. Ошибки

## Defer

* Механизм отложенного вызова некоторой функции (или метода) при выходе из другой функции
* Позволяет избежать дублирований кода (особенно при явной обработке ошибок)

		var m sync.Mutex
		m.Lock()
		if err := foo(); err != nil {
			m.Unlock() // unlock on error
			return err
		}
		// ...
		if err := bar(); err != nil {
			m.Unlock() // unlock on error
			return err
		}

## Defer

* Мы можем сказать, что некоторая функция должна быть вызвана при любом раскладе при выходе из функции (даже при панике)

		m.Lock()
		defer m.Unlock()
		// ...
		if err != nil {
			return err // будет вызван Unlock при выходе из функции
		}

* Сам вызов происходит при выходе из функции, однако аргументы рассчитываются в момент объявления defer
* Функция может иметь множество объявлений defer, и гарантируется, что они будут позваны в обратном порядке их объявлению
* defer имеет отношение именно к функции (defer в if, for и прочих равносилен другим объявлениям)
* Обычно defer используется для освобождения некоторых ресурсов и объявляется сразу после захвата

## Defer

* Кроме освобождения ресурсов, defer может быть полезен для выполнения различных действий при выходе из функции

		func bigSlowOperation() {
			defer trace("bigSlowOperation")() // don't forget the extra parentheses
			// ...lots of work...
			time.Sleep(10 * time.Second) // simulate slow operation by sleeping
		}
		func trace(msg string) func() {
			start := time.Now()
			log.Printf("enter %s", msg)
			return func() { log.Printf("exit %s (%s)", msg, time.Since(start)) }
		}

* Также defer может использоваться для модификации возвращаемых значений (для этого они должны быть именованными)

## Panic

* Экстренное завершение нормального исполнения программы с досрочным выходом из функций (пока не будет поймано)
* Зачастую это ситуации, когда дальнейшее выполнение может быть некорректно (например, разыменование nil, неправильное приведение типа, ...)
* По своей природе сильно похож на исключения в других языках (но исключения и паники используются в абсолютно разных контекстах)
* При выходе из функции в процессе паники вызываются все defer'ы для этой функции
* В случае, если паника не поймана, она приводит к завершению выполнения программы (и печатает лог для разбора)
* Панику можно кинуть самому с помощью функции `panic` (принимает один аргумент любого типа)

## Panic

* Паники зачастую используют для проверки логической неконсистентности программы (что в других языках делается через assert)
* "Ожидаемые" ошибки (сетевые, файловой системы, валидации, ...) не должны приводить к паникам
* Также паники бывают в ситуациях, когда теоретически ошибка может быть, но практически (с точки зрения логики кода) ее быть не должно (см. `regexp.MustCompile`)

## Recover

* Позволяет прекратить выполнение паники и получить переданный в нее объект
* Вызов `recover` вне ситуации паники возвращает nil
* Полезна в ситуациях, когда мы не хотим экстренно завершать программу (например, обработка одного запроса web-сервера спаниковала, но мы не хотим складывать весь сервис)
* Так как в процессе паники вызываются только `defer`'ы, то `recover` имеет смысл только внутри `defer'а`
* Есть плохая, но встречающаяся практика, когда с помощью паники раскручивают стек рекурсивных вызовов до первого, где панику ловят и возвращают обычную ошибку

## Методы

* Фактически, метод - обычная функция в выделенным отдельно аргументом (объявляется до имени функции)

		type Point struct{ X, Y float64 }
		// traditional function
		func Distance(p, q Point) float64 {
			return math.Hypot(q.X-p.X, q.Y-p.Y)
		}
		// same thing, but as a method of the Point type
		func (p Point) Distance(q Point) float64 {
			return math.Hypot(q.X-p.X, q.Y-p.Y)
		}

* Объект вызова метода - method receiver
* Receiver может иметь любое имя (более того, имена `this` или `self` считается плохим тоном)
* Часто можно встретить, что receiver называется по первой букве типа

## Методы

* Для каждого типа свой namespace для имен методов, так что они не конфликтуют с функциями и методами других типов
* Метод может быть у любого типа (не только структуры)

		type Path []Point
		func (p Path) Distance() float64 {
			...
		}

* Методы могут быть объявлены только в рамках того же пакета
* Receiver такой же аргумент, как и другие, так что он передается по значению в примере выше

## Методы

* Метод можно привязать не к самому типу, а к типу указателя
* В этом случае появляется возможность модифицировать receiver
* По соглашению, если есть хотя бы один pointer receiver, то все методы объявляются с pointer receiver
* Запрещено объявлять методы для типов, которые являются алиасами на указатели

		type P *int

		func (p P) foo() { // compile error: invalid receiver type P (P is a pointer type)
		}

* Метод с pointer receiver можно вызывать как на указателе, так и на самом объекте (будет неявное взятие адреса)
* Однако, нельзя позвать такой метод для значения, от которого нельзя взять адрес (например, значение в map через [])

## Методы

* Методы, имеющие receiver по значению, мы можем позвать и для указателей (так как всегда можно получить значение по указателю)
* Так как receiver участвует как обычный аргумент, он вполне может быть `nil`, и это не будет ошибкой (некоторые библиотеки обрабатывают это)
* При встраивании типов доступен сокращенный синтаксис вызова методов (по аналогии с полями)
* Можно использовать методы как значения (передавать в функции и т.д.)
* Выражение `p.Distance` (method value) возвращает функцию, привязанную к `p` (т.е. нет необходимости вызывать ее как метод)
* Выражение `Point.Distance` (method expression) возвращает функцию, где receiver становится первым аргументом функции
* Все те же правила для имен экспортируемых/неэкспортируемых сущностей применимы и для методов

## Интерфейсы

* Механизм обобщения (generalization) в Go
* Применяется "утиная типизация" - нет необходимости явно указывать, какие интерфейсы имплементирует данный тип (в отличии от многих других языков)
* Интерфейс - абстрактный тип, он только описывает набор методов (и никак не связан с имплементацией)
* Если мы работаем с значением типа интерфейс, мы только можем знать, что объект может делать, но ни чем он является (но можем предполагать, об этом отдельно :) )

## Интерфейсы

* В Go интерфейсы, обычно, имеют достаточно малый набор методов (см. интерфейсы стандартной библиотеки)
* Можно воспринимать интерфейс как контракт между вызывающей стороной и вызываемой
* При этом, вызываемой стороне неважно, какой тип скрывается за интерфейсом - важно лишь наличие нужных методов

		package fmt

		func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)

		func Printf(format string, args ...interface{}) (int, error) {
			return Fprintf(os.Stdout, format, args...)
		}

		func Sprintf(format string, args ...interface{}) string {
			var buf bytes.Buffer
			Fprintf(&buf, format, args...)
			return buf.String()
		}

## Интерфейсы

* Среди интерфейсов стандартной библиотеки можно выделить `io.Writer`, `io.Reader`,
`io.Closer`, их комбинации (похоже на встраивание), `fmt.Stringer`


		type ReadWriter interface {
			Reader
			Writer
		}

* Pointer receiver имеет важное значение для интерфейсов. Например в ситуации,

		func (p *Point) String() string {...}

только указатель на Point будет удовлетворять интерфейсу `fmt.Stringer`

* Хорошим тоном считается имплементировать методы стандартных интерфейсов вместо использования своих сигнатур
* Зачастую можно встретить подход: функция возвращает как можно больше (конкретный тип), но требует как можно меньше (интерфейс)


## Интерфейсы

* Из-за отсутствия в языке поддержки дженериков (которые скоро будут!), в большом количестве мест встречается пустой интерфейс `interface{}` - ему удовлетворяет любой тип
* Фактически, интерфейс - структура с двумя полями: type и value. Zero value для интерфейса - оба поля nil
* Динамический тип определяет, является ли интерфейс nil или нет
* Вызов метода на nil-интерфейсе вызывает панику
* Нужно понимать, что nil-интерфейс и интерфейс, содержащий nil (т.е. имеющий динамический тип) - разные понятия
* Интерфейсы можно сравнивать между собой - они равны, если имеют одинаковые значения и одинаковый динамический тип

## Type assertion

* Если мы знаем, какой тип скрывается за интерфейсом (или, например, что скрывается тип, который удовлетворяет большему интерфейсу)
мы можем привести значение к этому типу
* Этот механизм используется, в том числе, для получения конкретных ошибок из интерфейса `error`

		var w io.Writer
		w = os.Stdout
		f := w.(*os.File)          // success: f == os.Stdout
		c := w.(*bytes.Buffer)     // panic: interface holds *os.File, not *bytes.Buffer
		c, ok := w.(*bytes.Buffer) // don't panic, but ok == false

## Type switch

* Позволяет выбрать из предположений нужный тип. Например, может использоваться при написании `Printf`

		switch x.(type) {
			case nil:       // ...
			case int, uint: // ...
			case bool:      // ...
			case string:    // ...
			default:        // ...
		}

## Ошибки

* Все ошибки возвращаются явным образом с типом встроенного интерфейса `error` (исключение - panic, о нем отдельно)

		type error interface {
        Error() string
    }

* Можно создавать ошибки различных типов, главное, чтобы они удовлетворяли интерфейсу
* Ошибки можно сравнивать с nil и между собой (устаревший вариант, после go 1.13 для сравнения используются `errors.Is` и `errors.As`)
* Метод `errors.Unwrap` вызывает соответствующий метод у типа, если он определен, либо возвращает nil

## Ошибки

* Ошибки могут оборачивать одна другую: `fmt.Errorf("failed: %w", ErrNotFound)`
* `errors.Is` - в цепочке ошибок есть ошибка-переменная (`var ErrNotFound = errors.New("not found")`)
* `errors.As` - в цепочке ошибок есть ошибки с нужным типом