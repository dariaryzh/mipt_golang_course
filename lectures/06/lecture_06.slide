# Программирование на языке Go

Лекция 6. Механизмы синхронизации

## Мультиплексирование

* Мультиплексирование позволяет объединять чтение (или запись) для нескольких каналов
* Из-за удобства этого механизма некоторые сущности, не связанные с коммуникацией, используют каналы
(`context.Done`, `time.After`)
* Кроме этого, данный механизмм позволяет прочитать или записать что-то без блокировки (т.е. в случае, если бы
случилась блокировка, мы выйдем, ничего не записав и не прочитав)

		select {
		case <-ch:
			// ...
		case <-ch2:
			// ...
		default:
			// ...
		}

## Отмена исполнения горутин

* Есть несколько способов (фактически, один, но разными сущностями) правильно отменить исполнение горутины
* Один - передать канал, из которого в select дожидаться сообщения о том, что можно завершиться
* Недостаток - сложно отменить некоторые потенциально долгие вещи (такие, как http-запрос)
* Другой способ - передавать контекст (пакет `context`)
* Две ключевых роли контекста - передача сигнала об отмене и передача данных далее при обработке (например, пользовательского запроса)

## Race condition

* При выполнении программы конкурентно мы не можем утверждать, что событие в одной горутине
произошло раньше или позже, чем другое событие в другой горутине
* Функция (или метод) concurrent-safe в случае, когда ее можно использовать из разных
горутин без дополнительной синхронизации. Тип concurrent-safe, если все его методы concurrent-safe
* В большинстве языков программирования (включая Go) большинство типов не concurrent-safe,
так как накладывает дополнительные расходы, которые далеко не всегда нужны
* В то же время, большинство функций в пакетах считаются concurrent-safe (но если они меняют
глобальные объекты, то могут быть и не concurrent-safe)

## Race condition

* Состояние гонки - ошибка проектирования многопоточной системы или приложения, при которой работа системы
или приложения зависит от того, в каком порядке выполняются части кода
* Зачастую, состояние гонки возникает из-за отсутствия атомарности некоторых действий (т.е. другая
горутина может увидеть промежуточный результат в моменте выполнения операции)
* Даже большинство операций с числами не атомарны
* В большинстве ситуаций, когда некоторые данные меняются из нескольких горутин, возникает
data race

## Data race

* Нужно понимать, что data race может возникать только когда хотя бы одна горутина из нескольких
меняет данные
* Вполне корректно, например, инициализировать map в одном месте и потом **читать** из него
из нескольких горутин
* Но как только появляется горутина, которая пытается **писать** в map, то сразу же возникает
data race
* Каналы позволяют избегать data race путем коммуникации через общий объект, но данные передаются
в виде копии (и не возникает конкурентного доступа к общей памяти)

## sync.Mutex

* Мьютекс позволяет "ограничить" критические секции кода, где могут возникать гонки
* Когда мьютекс захвачен (`.Lock()` выполнился), гарантируется, что данная горутина единственная,
кто сейчас имеет заблокированный мьютекс
* Таким образом, мы можем "приостановить" исполнение других горутин, оперирующих с теми же
данными до момента, пока мы не закончим свои действия
* Обязательно необходимо отпустить мьютекс после выполнения операции (`.Unlock()`)
* При этом страдает "параллелилизм" программы - появляются точки синхронизации
* Под мьютекс следует заносить только критические секции, и стараться разблокировать его как можно
быстрее

## sync.RWMutex

* Продвинутый мьютекс, который позволяет конкурентно читать какие-либо данные и эксклюзивно их модифицировать
* Полезен в ситуациях, когда данные редко обновляются, но часто используются (например, раз в минуту
приходит новый курс доллара, а в течении этой минуты происходит множество конкурентных операций, использующих
это значение)
* Для использования читателями появляются методы `.RLock()` и `.RUnlock()`

## sync.Once

* Позволяет выполнить некоторую операцию ровно один раз (в одной из горутин, остальные дождутся
выполнения)
* Полезен, когда необходимо произвести некоторую инициализацию в момент первого вызова
и в дальнейшем использовать эти данные
* Объект имеет только один метод `.Do`, принимающий функцию для выполнения


## Race detector

* Если запустить `go test`, `go build` или `go run` с флагом `-race`, будет собрана специальная
версия программы, которая будет медленнее исполняться (так что это не для продакшена), но будет
отслеживать обращения к общей памяти
* Кроме этого, в этой версии программы будут отслеживаться все события синхронизации
* В случае, если находятся обращения к общей памяти без синхронизации, то программа сообщает об этом
* Встроенный race detector позволяет разработчикам сэкономить часы и даже дни поиска ошибок
* Подробнее можно почитать в `The Go Memory Model`

