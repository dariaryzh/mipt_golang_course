# Программирование на языке Go

Лекция 7. Тестирование

## Тестирование

* С увеличением кодовой базы проекта (и количества фичей) все сложнее тестировать код
"руками"
* Чем сложнее система, тем больше вероятность что-то сломать при внесении изменений в код
* Современные парадигмы разработки продуктов зачастую предполагают большое количетсво
"мелких" релизов, автоматически доезжающих до продакшена (с помощью CI/CD)
* При таком подходе невозможно на каждое изменение протестировать весь функционал -
на помощь приходят автоматизированные тесты (unit, функциональные, интеграционные, ...)
* Основное назначение тестов (очень грубо) - проверить, что код работает так, как ожидается
* В отличии от многих других языков программирования, инструменты для тестирования
  программ входят в стандартный тулчейн

## Тестирование в Go

* Тесты в Go располагаются в файлах `*_test.go`. Эти файлы "не видны" при сборке программы и
используются только при запуске тестов через `go test`
* Кроме тестов, в этих файлах могут находиться бенчмарки и примеры кода для документации
* Тест - обычная функция с именем `Test***`, принимающая в качестве аргумента специальный
объект `t *testing.T`
* Аналогично, бенчмарки носят имя `Benchmark***`; примеры - `Example***`
* Момент вызова `go test` функции в `*_test.go` файлах сканируются и создается временный
`main`-пакет, в котором вызываются нужные тесты

## Тестирование в Go

* Функция для теста выглядит следующим образом:

		func TestName(t *testing.T) {
			// ...
		}

* Суффикс (после префикса `Test`) должен начинаться с большой буквы
* Имя теста должно пояснять, какую функциональность (или часть функциональности) проверяет этот тест
* Аргумент функции необходим для сообщения о неуспешности проверок и логирования дополнительной информации
* Сообщить об ошибке можно через `t.Errorf`, завершить тест - `t.Fatalf`
* Есть некоторое количество пакетов, позволяющих не взаимодействовать с `t` напрямую

## Рандомизированное тестирование

* Тесты с заранее известными параметрами и результатом (табличные тесты) - один из вариантов тестов,
позволяющий протестировать важные и граничные кейсы работы
* Другой подход - рандомизированные тесты, когда входные параметры генерируются случайным образом
* В этом случае, результаты можно вычислять, например, более простым (и менее эффективным)
алгоритмом, который гораздо проще в имплементации
* В случае рандомизированных тестов важно выводить в лог достаточно информации для воспроизведения
прохождения тестов
* К рандомизированным тестам можно отнести fuzzing - когда мы передаем функции
неправильные, неожиданные или случайные данные. [Фаззинг: новое юнит тестирование. Дмитрий Вьюков, Google.](https://www.youtube.com/watch?v=EJVp13f_aIs)

## Тестирование в Go

* Тестировать можно также и main пакеты - в этом случае, зачастую, основную логику работы
выносят в отдельную функцию, а main занимается тривиальными операциями (например, парсит флаги)
* В этом случае важно, чтобы тестируемые функции не вызывали функции, завершающие выполнение
программы - например, `log.Fatal` или `os.Exit`

## Тестирование в Go

* Тесты (условно) можно разделить на два вида: `White Box` и `Black Box`
* В случае `Black Box` тестов проверяется только внешнее API (пакета, сервиса, ...)
* В случае тестирования пакета можно тесты положить в отдельный пакет (с именем `*_test`),
в этом случае тесты не будут иметь доступа до внутренностей пакета
* В случае `White Box` тесты пишутся с оглядкой на внутренности пакета
* С одной стороны, `Black Box` тесты проверяют реальные кейсы использования пакета, более
стабильны и не требуют модификации при изменении внутренней логики работы
* С другой стороны, `White Box` тесты позволяют производить тестирование более гранулярно и, например,
менять внутренности имплементации для избежания внешних зависимостей (например, `timeFunc`
в задаче `jwt`)

## External test packages

* Тесты для пакета могут располагаться в отдельных пакетах (с именем `*_test`)
* Это может быть полезно как для ограничения доступа к внутренностям пакета, так и для
разрешения циклических зависимостей в тестах
* Однако, когда мы пишем external test package для `White Box` тестов, возникает проблема с доступом
к внутренним объявлениям пакета
* В этом случае можно встретить файлы `export_test.go`, которые нужны для "экспортирования"
внутренних сущностей в тесты ([пример в fmt](https://golang.org/src/fmt/export_test.go))


## Полезные пакеты для тестирования

* [stretchr/testify](https://github.com/stretchr/testify) - пакет, предоставляющий более удобные
инструменты для написания тестов
* [golang/mock](https://github.com/golang/mock) - пакет для генерации и использования моков в тестах
* [uber-go/goleak](https://github.com/uber-go/goleak) - Goroutine leak detector
* [DATA-DOG/go-sqlmock](https://github.com/DATA-DOG/go-sqlmock) - библиотека для написания моков к базам данных,
работающим через `database/sql`
* [httptest](https://golang.org/pkg/net/http/httptest/) - стандартный пакет, упрощающий тестирование
http-сервисов

## Mocking

* Зачастую в unit-тестах мы хотим протестировать определенную бизнес-логику "в вакууме"
* В этом случае мы можем "подменить" реальную имплементацию чего-то пустышкой (удовлетворяющей
нужному нам интерфейсу), которая будет всегда вести себя так, как мы запрограммировали
* Например, мы можем исключить отправку нотификаций пользователям, лишь проверяя, что данный вызов
состоялся
* Или мы можем вместо использования временной базы описать ожидаемые запросы и результат их выполнения
* В том числе, mocking позволяет избежать "флапающих" тестов (когда без каких-либо изменений
тест то проходит, то нет)

## Code coverage

* Одна из распространенных методик оценки "насколько хорошо протестирован пакет"
* При запуске тестов просчитывается, какие строки кода исполнялись (и, возможно, сколько раз)
* Хорошее покрытие кода тестами абсолютно не означает, что код не содержит багов
* Тем не менее, хорошо покрытый тестами код с большей вероятностью работает стабильно и
делает то, что от него ожидают, в важных кейсах
* Зачастую в популярных пакетах можно встретить `code coverage` порядка 80-90%. Это отличный показатель,
так как из-за явной обработки ошибок появляется много строк кода, исполнение которых маловероятно и тяжело для тестирования
* Go имеет встроенную утилиту для работы с `code coverage`: `go tool cover`

## Benchmarks

* Бенчмарк - функция в файлах `*_test.go`, начинающаяся на `Benchmark` и принимающая в
аргументе `b *testing.B`
* Объект аргумента предоставляет большинство методов, доступных в `testing.T`, дополняя
их специфичными для бенчмарков методами и полями
* Основное - `b.N` - количество итераций, которое нужно проделать
* Чтобы запустить бенчмарки, необходимо передать в `go test` аргумент `-bench` с regexp
бенчмарков, которые запустить (в случае `.` запускаются все бенчмарки пакета)
* Зачастую бенчмарки испольуются для сравнения различных имплементаций или времени работы
алгоритма в зависимости от размера входных данных
* [https://pkg.go.dev/golang.org/x/tools/cmd/benchcmp](https://pkg.go.dev/golang.org/x/tools/cmd/benchcmp) -
утилита, позволяющая сравнивать между собой различные запуски бенчмарков

## Profiling

* Профилирование помогает найти узкие места в программе, которые можно оптимизировать
* CPU profile - для запущенного процесса ОС с некоторой периодичностью (раз в несколько миллисекунд)
прерывает исполнение и записывает, в каких местах исполнения находится программа
* Heap profile - внутренняя функция выделения памяти записывает кто вызывает аллокации
* Blocking profile - записываются все события блокировки горутин (на мьютексах, каналах, ...)
* Обычно, профиль собирают на бенчмарках или на реальных программах, так как тесты зачастую
заточены больше на проверку логики, чем на оценку эффективности работы
* Для отображения профиля, помимо самого профиля, необходим бинарник с программой. В случае
вызова `go test` с записью профиля остается собранный временный бинарник с тестами

## Примеры

* Кроме тестов и бенчмарков, в `*_test.go` файлах располагаются примеры кода для документации
* Это позволяет избежать ситуаций, когда примеры кода в документации устарели и не запускаются
* Функция примера не принимает аргументов и начинается с `Example`
* Посмотреть сгенерированную документацию можно через `go doc`
* Если пример заканчивается на комментарий `// Output:`, то при тестировании будет вызвано
сравнение вывода примера с каноничным