# Программирование на языке Go

Лекция 5. Конкурентность и параллелизм. Горутины. Каналы

## Многопоточность

* Последние годы (даже десятилетия) нет существенного прогресса в производительности процессоров (на одно ядро)
* Даже в смартфонах процессоры имеют по несколько ядер
* В случае пользовательских устройств многозадачность системы утилизирует все ядра даже в случае
программ, написанных для запуска на одном ядре (однако такие программы, все равно, обычно используют несколько потоков)
* В случае серверов, обслуживающих пользовательские запросы, обычно запущен один основной процесс,
утилизирующий ресурсы по максимуму
* Многопоточные программы позволяют утилизировать по максимуму мощность многоядерных процессоров,
однако, писать корректные многопоточные программы значительно сложнее

## Конкурентность

* В русской литературе, зачастую, не выделяют отдельно конкурентность, относя ее к параллелизму
* Однако, конкурентность != параллелизм
* Конкурентная программа может быть запущена на одном потоке, при этом работать производительнее
аналогичной многопоточной программы (например, сервер, где много времени процесс ожидает данные по сети)
* Go изначально проектировался так, что писать конкурентные (и многопоточные) программы в нем легко
* Более того, сетевой стек написан с использованием асинхронных операций, что позволяет избежать
ожидания сетевых данных, отдав исполнение другой части кода

## Конкурентное программирование в Go

* Go предоставляет возможность использовать два стиля конкурентного программирования
* Один из них - communicating sequential processes (CSP) - передача данных между независимыми "исполнителями"
(горутинами) через методы взаимодействия (каналы)
* Другой, более традиционный - shared memory multithreading - враимодействие конкурентных "исполнителей"
с общей памятью (с синхронизацией доступа через примитивы синхронизации, такие как мьютекс и другие)

## Горутины

* Горутина (goroutine) - отдельный "исполнитель" некоторого кода, независимый от других
* В отличии от обычных функций (routine), горутины исполняются конкурентно (параллельно или чередуя исполнение)
* Следует учитывать, что горутина - не то же самое, что поток (хотя сценарии использования очень похожие)
* В любой программе есть, как минимум, одна горутина - в ней вызывается `main`
* Чтобы вызвать функцию в отдельной горутине, достаточно перед вызовом функции добавить ключевое слово `go`

		go foo(42)

## Горутины

* Несмотря на то, что у программы может быть несколько горутин в исполнении, как только завершается горутина
с `main`, процесс завершается (не дожидаясь исполнения других горутин). Для ожидания можно использовать `sync.WaitGroup`
* Для горутины нет никакого отдельного объекта, который бы позволял управлять ее (в частности, завершать ее исполнение).
Горутина завершается (и освобождает выделенные на нее ресурсы) только в момент завершения функции, которая была в ней запущена
* Существуют механизмы (например, пакет `context`), позволяющие сообщать в горутины (в которых, обычно, выполняются долгие операции,
в реальных программах - в основном, ожидание чего то), что ее можно досрочно завершить

## Горутины

* Фактически, горутина то же самое, что можно встретить в других языках программирования под
названием сопрограмма (coroutine, корутина)
* Основная особенность корутин - они могут прерывать свое исполнение и продолжать с того же места, как будто прерывания не было
* Это позволяет отдавать исполнение (т.е. CPU) другой корутине, пока первая ожидает чего-то (например, I/O-операции или
освобождения примитива синхронизации)
* Для удобного использования корутин на уровне приложения существует scheduler (который работает независимо
от системного), в случае горутинг этим занимается runtime Go.

## Горутины

* При старте программы создается несколько потоков (указывается в переменной окружения `GOMAXPROCS`, по умолчанию - количество ядер),
на которых запускаются горутины (параллельно в случае нескольких потоков)
* Горутины могут переключаться (вызов функции, блокировка, вызов `runtime.Gosched`), давая исполнение другим горутинам
* В большинстве случаев, это выглядит как "параллельное" исполнение множества горутин, однако, можно
написать горутину так, что она не будет снята с исполнения длительное время (в ней не будет точек переключения)
* Например, это могут быть какие-то численные вычисления с множеством циклов, не вызывающие другие функции
* В этом случае, рекомендуется, вручную вызывать `runtime.Gosched`

## Горутины

* У каждой горутины существует свой стек исполнения, равный нескольким килобайтам
* Переключение горутины для исполнения на потоке - операция, сильно более дешевая, чем переключение системного потока
* Таким образом, для программы на Go нормальная ситуация, когда одновременно существуют сотни и даже тысячи горутин
(в случае такого количества потоков процесс может сильно тормозить из-за оверхэда на переключение контекстов)
* Подробнее: [раз](https://habr.com/ru/post/141853/), [два](https://habr.com/ru/company/otus/blog/527748/)
* [Про асинхронность и корутины в C++](https://habr.com/ru/post/201826/)

## Каналы

* Каналы позволяют нескольким горутинам обмениваться информацией (но не только)
* В канал можно что-то записать и прочитать (потокобезопасно)
* Канал типизирован (так же, как `map` и `slice`), т.е. можно передавать объекты только определенного типа
* Тип канала - `chan T`, где `T` - некоторый тип. Канал должен создаваться через `make`

		ch := make(chan int)

* Также существуют типы однонаправленных каналов (`<-chan T`, `chan<- T`) - можно контролировать,
что из канала никто не будет читать либо что в канал никто не будет писать
* Как и в случае с `map`, канал - reference type, т.е. при передаче куда либо он будет передаваться "по ссылке"

## Каналы

* Zero value для канала - nil
* Каналы могут сравниваться на равенство между собой и с nil
* В канал можно записать значение и прочитать значение из него

		val := <-ch
		ch <- newVal

* Кроме этого, канал можно закрыть (`close(ch)`), при этом в канал нельзя писать (вызовет панику),
но можно читать - будет возвращено zero value
* При чтении из канала можно получить вторым аргументом, было ли прочитано значение

		val, ok := <-ch

## Каналы

* Канал может быть буферизированным или нет
* Для создания буферизированного канала необходимо в `make` вторым аргументом передать размер буфера
* Небуферизированный канал - буфер размера 0
* Операции с каналами могут быть блокирующими: запись в канал сверх буфера заблокируется до того момента,
пока кто-то не прочитает значение из канала; чтение из пустого канала (никто не пишет в него и ничего нет в буфере)
тоже заблокирует выполнение
* Небуферизированные каналы можно использовать для синхронизации каких-либо дуйствий в разных горутинах
(т.к. для разблокировки операции нужно, чтобы одновременно кто-то читал и писал)

## Каналы

* Зачастую каналы используются для составления пайплайнов (pipeline): несколько горутин принимают
значения из канала и передают в другой канал, выстраивая цепочку обработки
* При этом, самое медленное звено в цепочке определяет скорость обработки данных
* Но можно сделать несколько параллельных звеньев, которые будут читать из одной очереди и писать в одну очередь


## Каналы

* По значениям в канале можно итерироваться через range

		for val := range ch {...}
		// Эквивалентно
		for {
			val, ok := <-ch
			if !ok {
				break
			}
			...
		}

* Единственный способ выйти из такого цикла - закрыть канал (обычно, закрывает кто-то снаружи)

## Мультиплексирование

* Мультиплексирование позволяет объединять чтение (или запись) для нескольких каналов
* Из-за удобства этого механизма некоторые сущности, не связанные с коммуникацией, используют каналы
(`context.Done`, `time.After`)
* Кроме этого, данный механизмм позволяет прочитать или записать что-то без блокировки (т.е. в случае, если бы
случилась блокировка, мы выйдем, ничего не записав и не прочитав)

		select {
		case <-ch:
			// ...
		case <-ch2:
			// ...
		default:
			// ...
		}

## Отмена исполнения горутин

* Есть несколько способов (фактически, один, но разными сущностями) правильно отменить исполнение горутины
* Один - передать канал, из которого в select дожидаться сообщения о том, что можно завершиться
* Недостаток - сложно отменить некоторые потенциально долгие вещи (такие, как http-запрос)
* Другой способ - передавать контекст (пакет `context`)
* Две ключевых роли контекста - передача сигнала об отмене и передача данных далее при обработке (например, пользовательского запроса)
